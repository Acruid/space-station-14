using System.Collections.Generic;
using System.Text;
using SS14.Client.Graphics.Sprites;
using SS14.Client.ResourceManagement;
using SS14.Shared.Maths;

namespace SS14.Client.UserInterface.Controls
{
    /// <summary>
    ///     Panel that displays read-only rich text
    /// </summary>
    internal class RichTextPanel : Panel
    {
        public FormattedTextStream Text { get; }

        public RichTextPanel()
        {
            var font = _resourceCache.GetResource<FontResource>(string.Empty);
            Text = new FormattedTextStream(font);
        }

        protected override void DrawContents()
        {
            base.DrawContents();

            // draw the text
            Text.Draw(Position.X, Position.Y);
        }

        protected override void OnCalcRect()
        {
            base.OnCalcRect();

            // recalculate size & line endings
            Text.Width = Width;
            Text.Height = Height;
        }

        internal class FormattedTextStream
        {
            // guesstimate of some buffer sizes
            private const int maxLineChars = 80;

            private const int maxLines = 24;
            private const int maxCapacity = 80 * 24;

            private readonly Font _font;

            private readonly List<char> _charBuffer;
            private readonly List<int> _lineBreaks;
            private readonly uint _fntSize;

            private readonly TextSprite _textSprite;
            private readonly StringBuilder _sb;

            private int _scrOffX;
            private int _scrOffY;

            public int MaxCapacity { get; }

            public int Width { get; set; }
            public int Height { get; set; }

            public FormattedTextStream(Font font)
            {
                _font = font;
                _fntSize = 16;
                MaxCapacity = maxCapacity;
                _charBuffer = new List<char>(maxCapacity);
                _lineBreaks = new List<int>(maxLines);

                _textSprite = new TextSprite(string.Empty, _font, _fntSize);

                _sb = new StringBuilder(maxLineChars);
            }

            public void Append(string str)
            {
                var length = str.Length;
                var lines = str.Split('\n');

                // remove at least length chars from top of buffer so we don't go over

                // add our lines and returns
                foreach (var line in lines)
                {
                    if (string.IsNullOrWhiteSpace(line))
                        continue;

                    _charBuffer.AddRange(line);
                    _lineBreaks.Add(_charBuffer.Count);
                }
            }

            public void Draw(int scrX, int scrY)
            {
                _scrOffX = scrX;
                _scrOffY = scrY;

                var curX = 0;
                var curY = 0;

                var blockX = 0;
                var lbIndex = 0;

                var lbPos = _lineBreaks.Count > 0 ? _lineBreaks[lbIndex] : 0;

                // let the parsing begin!
                var length = _charBuffer.Count;
                for (var i = 0; i < length && curY < Height; i++)
                {
                    var chr = _charBuffer[i];
                    var chrSz = ChrWidth(chr);

                    // check linebreak
                    if (i == lbPos)
                    {
                        DrawString(blockX, curY, _sb.ToString());
                        _sb.Clear();
                        AddLine(ref curX, ref curY);
                        blockX = 0;

                        if (_lineBreaks.Count > lbIndex + 2)
                        {
                            lbIndex++;
                            lbPos = _lineBreaks[lbIndex];
                        }
                        else
                        {
                            // position will nerver be reached
                            lbPos = length + 1;
                        }

                        i--;
                        continue;
                    }

                    // draw line
                    if (curX + chrSz > Width)
                    {
                        DrawString(blockX, curY, _sb.ToString());
                        _sb.Clear();
                        AddLine(ref curX, ref curY);
                        blockX = 0;
                        i--; // backup to re-process char
                        continue;
                    }

                    // Default: append char
                    curX += chrSz;
                    _sb.Append(chr);

                    // end of buffer
                    if (i == length - 1)
                        DrawString(blockX, curY, _sb.ToString());
                }

                _sb.Clear();
            }

            private int GetLineSpacing()
            {
                return (int) _font.GetLineSpacing(_fntSize);
            }

            private void AddLine(ref int x, ref int y)
            {
                x = 0;
                y += GetLineSpacing();
            }

            private void DrawString(int x, int y, string str)
            {
                _textSprite.Text = str;
                _textSprite.Position = new Vector2(x + _scrOffX, y + _scrOffY);
                _textSprite.FillColor = Color.DarkSlateBlue;
                _textSprite.Draw();
            }

            private int ChrWidth(char chr)
            {
                return (int) _font.GetGlyph(chr, _fntSize, false, 0).Advance;
            }
        }
    }
}
